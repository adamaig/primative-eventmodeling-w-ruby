# 20250726-12.30 - Library Refactoring Plan
**Date:** July 26, 2025 12:30  
**Agent:** GitHub Copilot (GPT-4)  
**Session Theme:** EventModeling Library Refactoring to Standard Layout

## Summary

This document outlines a comprehensive plan to refactor the EventModeling Ruby library from a single-file implementation to a standard, modular library structure. The refactoring will improve maintainability, testability, and follow Ruby community conventions.

### Key Implementation Decisions
- **Modular Architecture**: Split the monolithic file into logical components
- **Standard Ruby Layout**: Follow established conventions for gem structure
- **Enhanced Error Handling**: Create a proper error hierarchy
- **Event Encapsulation**: Introduce an Event class for better data modeling
- **Improved Testing**: Separate spec files for each component
- **Version Management**: Dedicated version file for proper gem versioning

### Architecture Changes
- Move from single `lib/event_modeling.rb` to multi-file structure
- Extract errors into dedicated error hierarchy
- Create Event class for better encapsulation
- Maintain backward compatibility with existing interface
- Improve initialization of instance variables

### Next Steps
1. Create directory structure and new files
2. Extract and move code to appropriate files
3. Update require statements and dependencies
4. Refactor specs to match new structure
5. Update documentation and examples
6. Test backward compatibility

## Refactoring Plan

### Phase 1: Directory Structure Setup

Create the following directory structure:
```
lib/
├── event_modeling/
│   ├── version.rb
│   ├── event_store.rb
│   ├── errors.rb
│   └── event.rb
└── event_modeling.rb
```

### Phase 2: Extract Components

#### 2.1 Version Management (`lib/event_modeling/version.rb`)
- Define VERSION constant
- Enable proper gem versioning
- Support semantic versioning practices

#### 2.2 Error Hierarchy (`lib/event_modeling/errors.rb`)
- Base `Error` class for all EventModeling errors
- `ConcurrencyError` for version conflicts
- `StreamNotFoundError` for missing streams
- `InvalidEventError` for malformed events

#### 2.3 Event Class (`lib/event_modeling/event.rb`)
- Encapsulate event data and behavior
- Provide validation for type and data
- Support metadata enhancement (version, timestamp)
- Implement equality and hash methods
- Add string representation for debugging

**Key Methods:**
- `initialize(type:, data:, version: nil, timestamp: nil)`
- `to_h` - Convert to hash for storage
- `with_metadata(version:, timestamp:)` - Create enhanced copy
- `==`, `eql?`, `hash` - Equality and collection support
- `to_s`, `inspect` - String representation

#### 2.4 EventStore Refactoring (`lib/event_modeling/event_store.rb`)
- Move EventStore class to dedicated file
- Initialize all instance variables in constructor
- Maintain all existing public methods
- Keep backward compatibility

**Constructor Changes:**
```ruby
def initialize
  @streams = {}
  @subscriptions = {}
  @snapshots = {}
end
```

#### 2.5 Main Module (`lib/event_modeling.rb`)
- Require all component files
- Provide module-level documentation
- Add convenience methods
- Maintain top-level interface

### Phase 3: Spec Structure Updates

#### 3.1 Update `spec/spec_helper.rb`
- Update require statement to use main module
- Maintain existing RSpec configuration
- Ensure proper auto-loading

#### 3.2 Create Component Specs
- `spec/event_modeling/event_spec.rb` - Event class tests
- `spec/event_modeling/event_store_spec.rb` - EventStore tests
- `spec/event_modeling/errors_spec.rb` - Error hierarchy tests
- Keep existing `spec/event_modeling_spec.rb` for integration tests

#### 3.3 Test Categories
- **Unit Tests**: Individual component behavior
- **Integration Tests**: Cross-component interactions
- **Backward Compatibility**: Ensure existing API works
- **Error Handling**: Proper error scenarios

### Phase 4: Documentation Updates

#### 4.1 YARD Documentation
- Update all class and method documentation
- Add proper `@since` tags
- Include usage examples for new Event class
- Document error conditions

#### 4.2 README Updates
- Update usage examples to show new structure
- Maintain backward compatibility examples
- Add migration guide for existing users

### Phase 5: Backward Compatibility

#### 5.1 Maintain Existing Interface
- All public EventStore methods remain unchanged
- Hash-based event input still supported
- No breaking changes to method signatures

#### 5.2 Deprecation Strategy
- Mark deprecated methods with `@deprecated` tags
- Provide upgrade path in documentation
- Consider future removal timeline

### Phase 6: Testing and Validation

#### 6.1 Test Migration
- Run existing tests against new structure
- Verify all specs still pass
- Add tests for new Event class
- Test error conditions

#### 6.2 Performance Validation
- Ensure no performance regression
- Memory usage should remain similar
- Event processing speed maintained

## Benefits of Refactoring

### 1. **Maintainability**
- Smaller, focused files easier to understand and modify
- Clear separation of concerns
- Easier to locate and fix bugs

### 2. **Testability**
- Individual components can be tested in isolation
- Better test organization and coverage
- Easier to mock dependencies

### 3. **Extensibility**
- Easier to add new features to specific components
- Plugin architecture possibilities
- Better support for inheritance and composition

### 4. **Ruby Community Standards**
- Follows established gem structure conventions
- Easier for Ruby developers to understand
- Better tooling support (IDEs, linters, etc.)

### 5. **Error Handling**
- Proper error hierarchy for better exception handling
- More specific error types for different scenarios
- Better debugging and error reporting

### 6. **Event Modeling**
- Event class provides better encapsulation
- Type safety and validation
- Enhanced debugging with proper string representation

## Implementation Checklist

- [ ] Create directory structure
- [ ] Extract version.rb
- [ ] Extract errors.rb with proper hierarchy
- [ ] Create Event class with full functionality
- [ ] Move EventStore to separate file
- [ ] Update main module with requires
- [ ] Update spec_helper.rb
- [ ] Create component-specific spec files
- [ ] Run full test suite
- [ ] Update documentation
- [ ] Verify backward compatibility
- [ ] Performance testing
- [ ] Code review and cleanup

## Risk Mitigation

### 1. **Backward Compatibility**
- **Risk**: Breaking existing code
- **Mitigation**: Maintain all public interfaces, add comprehensive tests

### 2. **Performance Impact**
- **Risk**: Additional file loading overhead
- **Mitigation**: Benchmark before/after, optimize requires

### 3. **Testing Complexity**
- **Risk**: Test suite becomes harder to manage
- **Mitigation**: Clear test organization, good documentation

### 4. **Documentation Debt**
- **Risk**: Incomplete or outdated docs
- **Mitigation**: Update all docs as part of refactoring

## Success Criteria

1. All existing tests pass without modification
2. New component tests provide good coverage
3. Event class provides expected functionality
4. Error hierarchy works as designed
5. Documentation is complete and accurate
6. Performance remains within acceptable bounds
7. Code follows Ruby style guidelines
8. Backward compatibility is maintained

## Full Conversation

**User:** how would i refactor the EventModeling module to use a more standard library layout

**Assistant:** Looking at your current implementation, I can help you refactor to a more standard Ruby library layout. Here's how to restructure the EventModeling library:

## Suggested Directory Structure

````
lib/
├── event_modeling/
│   ├── version.rb
│   ├── event_store.rb
│   ├── errors.rb
│   └── event.rb
└── event_modeling.rb
````

## Implementation

First, create the main module file:

````ruby
# frozen_string_literal: true

require_relative 'event_modeling/version'
require_relative 'event_modeling/errors'
require_relative 'event_modeling/event'
require_relative 'event_modeling/event_store'

# EventModeling library for educational event-driven architecture patterns.
#
# This module provides a complete EventStore implementation demonstrating
# event sourcing concepts including persistence, retrieval, concurrency control,
# pub/sub subscriptions, and snapshot functionality.
#
# @example Basic usage
#   event_store = EventModeling::EventStore.new
#   event = EventModeling::Event.new(type: 'UserCreated', data: { name: 'John' })
#   event_store.append_event('user-123', event.to_h)
#
# @since 1.0.0
module EventModeling
  # Convenience method to create a new EventStore instance
  #
  # @return [EventStore] new EventStore instance
  def self.new_event_store
    EventStore.new
  end
end
````

Create the version file:

````ruby
# frozen_string_literal: true

module EventModeling
  # Current version of the EventModeling library
  VERSION = '1.0.0'
end
````

Extract errors to their own file:

````ruby
# frozen_string_literal: true

module EventModeling
  # Base error class for all EventModeling errors
  class Error < StandardError; end

  # Custom error for concurrency conflicts when expected version doesn't match current version
  class ConcurrencyError < Error; end

  # Error raised when attempting to operate on a non-existent stream
  class StreamNotFoundError < Error; end

  # Error raised for invalid event data
  class InvalidEventError < Error; end
end
````

Create an Event class for better encapsulation:

````ruby
# frozen_string_literal: true

module EventModeling
  # Represents an event in the event store.
  #
  # Events encapsulate the type and data payload, with version and timestamp
  # added automatically by the EventStore when appended.
  #
  # @example Creating an event
  #   event = Event.new(type: 'UserCreated', data: { name: 'John' })
  #
  # @since 1.0.0
  class Event
    attr_reader :type, :data, :version, :timestamp

    # Initialize a new Event instance.
    #
    # @param type [String] the event type identifier
    # @param data [Hash] the event payload data
    # @param version [Integer, nil] event version (set by EventStore)
    # @param timestamp [Time, nil] event timestamp (set by EventStore)
    # @raise [InvalidEventError] if type is not a String or data is not a Hash
    def initialize(type:, data:, version: nil, timestamp: nil)
      raise InvalidEventError, 'Event type must be a String' unless type.is_a?(String)
      raise InvalidEventError, 'Event data must be a Hash' unless data.is_a?(Hash)

      @type = type
      @data = data.dup.freeze
      @version = version
      @timestamp = timestamp
    end

    # Convert event to hash format for storage.
    #
    # @return [Hash] event as hash with symbol keys
    def to_h
      {
        type: @type,
        data: @data,
        version: @version,
        timestamp: @timestamp
      }.compact
    end

    # Create an enhanced copy with version and timestamp.
    #
    # @param version [Integer] the version number to assign
    # @param timestamp [Time] the timestamp to assign (defaults to current time)
    # @return [Event] new Event instance with version and timestamp
    def with_metadata(version:, timestamp: Time.now)
      Event.new(
        type: @type,
        data: @data,
        version: version,
        timestamp: timestamp
      )
    end

    # Check if two events are equal based on type and data.
    #
    # @param other [Event] event to compare with
    # @return [Boolean] true if events have same type and data
    def ==(other)
      return false unless other.is_a?(Event)

      @type == other.type && @data == other.data
    end

    alias eql? ==

    # Generate hash code for use in collections.
    #
    # @return [Integer] hash code based on type and data
    def hash
      [@type, @data].hash
    end

    # String representation of the event.
    #
    # @return [String] formatted event description
    def to_s
      version_info = @version ? " v#{@version}" : ''
      timestamp_info = @timestamp ? " at #{@timestamp}" : ''
      "Event[#{@type}#{version_info}#{timestamp_info}]: #{@data}"
    end

    alias inspect to_s
  end
end
````

Move EventStore to its own file:

````ruby
# frozen_string_literal: true

module EventModeling
  # EventStore class to manage events in an in-memory event sourcing system.
  #
  # This class provides a complete EventStore implementation for educational purposes,
  # demonstrating event-driven architecture patterns including event persistence,
  # retrieval, stream management, concurrency control, querying, pub/sub subscriptions,
  # and snapshot functionality.
  #
  # All events are stored in memory only and are lost when the application terminates.
  # Events are automatically enhanced with version numbers and timestamps.
  #
  # @example Basic usage
  #   event_store = EventStore.new
  #   event = { type: 'UserCreated', data: { name: 'John' } }
  #   event_store.append_event('user-123', event)
  #   events = event_store.get_events('user-123')
  #
  # @example With subscriptions
  #   event_store.subscribe_to_stream('user-123') do |event|
  #     puts "New event: #{event[:type]}"
  #   end
  #   event_store.append_event('user-123', event)  # triggers subscriber
  #
  # @since 1.0.0
  class EventStore
    # Initialize a new EventStore instance.
    #
    # Creates empty storage for streams, subscriptions, and snapshots.
    # All data is stored in memory and will be lost when the instance is destroyed.
    def initialize
      @streams = {}
      @subscriptions = {}
      @snapshots = {}
    end

    # ...existing code... (all your current EventStore methods remain the same)
  end
end
````

## Update Spec Structure

You should also update your spec structure:

````ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'event_modeling'

RSpec.configure do |config|
  config.expect_with :rspec do |c|
    c.syntax = :expect
  end

  config.mock_with :rspec do |c|
    c.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups
  config.filter_run_when_matching :focus
  config.example_status_persistence_file_path = "spec/examples.txt"
  config.disable_monkey_patching!
  config.warnings = true

  if config.files_to_run.one?
    config.default_formatter = "doc"
  end

  config.profile_examples = 10
  config.order = :random
  Kernel.srand config.seed
end
````

Create separate spec files:

````ruby
_modeling/event_spec.rb
# frozen_string_literal: true

require 'spec_helper'

RSpec.describe EventModeling::Event do
  describe '#initialize' do
    it 'creates an event with type and data' do
      event = described_class.new(type: 'UserCreated', data: { name: 'John' })
      
      expect(event.type).to eq('UserCreated')
      expect(event.data).to eq({ name: 'John' })
    end

    it 'raises error for invalid type' do
      expect {
        described_class.new(type: 123, data: {})
      }.to raise_error(EventModeling::InvalidEventError, 'Event type must be a String')
    end

    it 'raises error for invalid data' do
      expect {
        described_class.new(type: 'UserCreated', data: 'invalid')
      }.to raise_error(EventModeling::InvalidEventError, 'Event data must be a Hash')
    end
  end

  describe '#with_metadata' do
    it 'creates enhanced event with version and timestamp' do
      original = described_class.new(type: 'UserCreated', data: { name: 'John' })
      timestamp = Time.now
      
      enhanced = original.with_metadata(version: 1, timestamp: timestamp)
      
      expect(enhanced.version).to eq(1)
      expect(enhanced.timestamp).to eq(timestamp)
    end
  end
end
````

## Benefits of This Refactoring

1. **Standard Ruby Library Structure**: Follows Rails/Ruby conventions with separate files for each class
2. **Better Separation of Concerns**: Each class has its own file and responsibility
3. **Easier Testing**: Can test individual components in isolation
4. **Version Management**: Dedicated version file for gem versioning
5. **Error Hierarchy**: Well-organized error classes
6. **Enhanced Event Model**: Event class provides better encapsulation and validation
7. **Maintainability**: Easier to navigate and modify individual components

This structure makes your library more professional and easier to extend as it grows.

**User:** Generate a plan document based on your suggestions and add it to the chats folder. Then update the instructions file to specify that all recorded chat files should include a prefix based on the datetime in the format YYYMMDD-HH.MM.
