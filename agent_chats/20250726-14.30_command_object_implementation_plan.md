# Command Object Implementation Plan - EventModeling Ruby Library

**Date:** July 26, 2025, 2:30 PM  
**Agent:** GitHub Copilot (GPT-4)  
**Session Theme:** Planning Command Object Addition to EventModeling Library

## Summary

This document outlines the comprehensive plan for adding a generic Command object to the EventModeling Ruby library following CQRS (Command Query Responsibility Segregation) patterns. The Command implementation will use Option A (class-based approach) with test-first development.

### Key Implementation Decisions
- **Approach:** Class-based Command implementation (Option A)
- **Structure:** Immutable data containers following Event pattern
- **Development Order:** Specs first, then implementation (TDD approach)
- **Integration:** Seamless addition to existing EventModeling module structure
- **Scope:** Remove `to_event` method from initial implementation

## Current EventModeling Library Analysis

### Existing Structure
```
lib/event_modeling/
├── event_store.rb     # Complete EventStore implementation
├── event.rb           # Structured Event class with immutability
├── errors.rb          # Custom error classes
└── version.rb         # Version management

spec/event_modeling/
├── event_store_spec.rb
├── event_spec.rb
├── errors_spec.rb
└── version_spec.rb
```

### Design Patterns in Use
- **Immutable Objects**: Events freeze data on creation
- **Auto-enhancement**: EventStore adds version/timestamp to events
- **Validation**: Type and data validation in Event class
- **Module Namespacing**: All classes under `EventModeling::`
- **Comprehensive Documentation**: YARD docs with examples

## Command Object Design Specification

### Core Characteristics
1. **Immutable**: Commands frozen after creation (like Events)
2. **Data-only**: Pure data containers with no behavior (POROs)
3. **Intent-expressing**: Command names express user intent
4. **Validation**: Structural validation similar to Events
5. **Subclassable**: Allow application-specific command types
6. **Auto-generated metadata**: command_id and created_at timestamp

### Command Structure (Option A - Class-based)

```ruby
module EventModeling
  class Command
    attr_reader :type, :data, :command_id, :created_at

    def initialize(type:, data:, command_id: nil, created_at: nil)
      # Validation
      raise InvalidCommandError, 'Command type must be a String' unless type.is_a?(String)
      raise InvalidCommandError, 'Command data must be a Hash' unless data.is_a?(Hash)

      # Auto-generate metadata
      @type = type
      @data = data.dup.freeze
      @command_id = command_id || SecureRandom.uuid
      @created_at = created_at || Time.now

      freeze # Make command immutable
    end

    def to_h
      {
        type: @type,
        data: @data,
        command_id: @command_id,
        created_at: @created_at
      }
    end

    def ==(other)
      other.is_a?(Command) &&
        type == other.type &&
        data == other.data &&
        command_id == other.command_id
    end
  end
end
```

### Application-Specific Commands (Subclassing Example)

```ruby
class CreateUserCommand < EventModeling::Command
  def initialize(name:, email:)
    super(
      type: 'CreateUser',
      data: { name: name, email: email }
    )
  end
end

class UpdateUserCommand < EventModeling::Command
  def initialize(user_id:, name: nil, email: nil)
    super(
      type: 'UpdateUser',
      data: { user_id: user_id, name: name, email: email }.compact
    )
  end
end
```

## Implementation Plan (Revised Order)

### Phase 1: Command Specs (Test-First Development)
**File:** `spec/event_modeling/command_spec.rb`

**Test Coverage:**
1. **Basic Construction**
   - Creates command with type and data
   - Auto-generates command_id and created_at
   - Validates required parameters

2. **Immutability**
   - Command object is frozen after creation
   - Data hash is frozen (deep immutability)
   - Attempting to modify raises FrozenError

3. **Validation**
   - Raises InvalidCommandError for non-string type
   - Raises InvalidCommandError for non-hash data
   - Handles empty data gracefully

4. **Hash Conversion**
   - `to_h` returns complete command representation
   - Hash includes all metadata fields
   - Round-trip conversion preserves data

5. **Equality**
   - Commands with same type/data/command_id are equal
   - Commands with different data are not equal
   - Handles nil comparisons gracefully

6. **Inheritance**
   - Supports subclassing for application-specific commands
   - Subclasses inherit all base functionality
   - Custom constructors work correctly

7. **Metadata Handling**
   - Auto-generates UUID for command_id when not provided
   - Uses provided command_id when specified
   - Auto-generates created_at timestamp
   - Accepts explicit created_at for testing

### Phase 2: Core Command Class Implementation
**File:** `lib/event_modeling/command.rb`

**Implementation Features:**
1. **Base Command Class**
   - Immutable structure with attr_readers
   - Comprehensive validation
   - Auto-generation of metadata
   - YARD documentation with examples

2. **Error Handling**
   - Add `InvalidCommandError` to errors.rb
   - Descriptive error messages
   - Consistent with Event error patterns

3. **Integration**
   - Add require to main event_modeling.rb
   - Follow existing module patterns
   - Maintain backward compatibility

### Phase 3: Documentation and Integration
**Updates to Existing Files:**

1. **lib/event_modeling.rb**
   - Add `require_relative 'event_modeling/command'`
   - Update module documentation with Command examples

2. **lib/event_modeling/errors.rb**
   - Add `InvalidCommandError` class
   - Follow existing error pattern

3. **README.md** (future enhancement)
   - Add Command usage examples
   - Document CQRS relationship between Commands and Events

## Command vs Event Relationship

### CQRS Pattern Implementation
- **Commands**: Express user intent (write operations)
  - `CreateUserCommand` → "I want to create a user"
  - `UpdateProfileCommand` → "I want to update a profile"

- **Events**: Record what happened (facts)
  - `UserCreatedEvent` → "A user was created"
  - `ProfileUpdatedEvent` → "A profile was updated"

### Workflow Pattern
```ruby
# 1. Create Command (user intent)
command = CreateUserCommand.new(name: 'John', email: 'john@example.com')

# 2. Process Command (business logic - future implementation)
# command_handler.handle(command)

# 3. Generate Events (facts)
event = { type: 'UserCreated', data: command.data }

# 4. Store Events
event_store.append_event('user-123', event)
```

## Benefits of This Approach

### 1. Consistency with Existing Patterns
- Mirrors Event class structure and validation
- Follows same immutability and documentation patterns
- Integrates seamlessly with existing module structure

### 2. CQRS Alignment
- Clear separation: Commands (intent) vs Events (facts)
- Supports command/event sourcing workflows
- Educational value for event-driven architecture

### 3. Flexibility and Extensibility
- Base class supports generic commands
- Subclassing enables application-specific commands
- Future-proof for command handler integration

### 4. Developer Experience
- Familiar API following Event patterns
- Comprehensive validation and error handling
- Rich documentation with practical examples

## Files to Create/Modify

### New Files
1. `spec/event_modeling/command_spec.rb` - Comprehensive test suite
2. `lib/event_modeling/command.rb` - Core Command implementation

### Modified Files
1. `lib/event_modeling.rb` - Add Command require
2. `lib/event_modeling/errors.rb` - Add InvalidCommandError

## Success Criteria

### Phase 1 (Specs) Complete When:
- [ ] All Command test scenarios written and failing appropriately
- [ ] Test structure mirrors Event specs for consistency
- [ ] Edge cases and error conditions covered
- [ ] Inheritance and subclassing patterns tested

### Phase 2 (Implementation) Complete When:
- [ ] All Command specs pass
- [ ] Command class follows Event patterns and conventions
- [ ] YARD documentation comprehensive and accurate
- [ ] Integration with module structure complete
- [ ] No existing functionality affected

### Overall Success When:
- [ ] `bundle exec rspec` passes all tests including new Command specs
- [ ] Command objects are immutable and validated
- [ ] Subclassing works for application-specific commands
- [ ] Documentation explains Command vs Event relationship
- [ ] Library maintains backward compatibility

## Next Steps

**Immediate Action:** Begin Phase 1 by creating comprehensive Command specs that define the complete interface and behavior expectations before implementing any code.

**Session Scope:** Focus on Phase 1 only - create the test suite that will drive the implementation in the next session.

---

**Note:** This plan removes the `to_event` conversion method from the initial implementation as requested, focusing on pure Command functionality. The relationship between Commands and Events will be documented conceptually rather than implemented programmatically in this first iteration.
